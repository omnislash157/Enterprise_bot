# ==============================================================================
# TASK 2: AUDIT LOGGING RECON
# ==============================================================================
# Mission: Map existing logging infrastructure and audit trail insertion points

audit_recon:
  backend:
    current_logging: |
      Structured but incomplete:

      1. Analytics events logged via analytics_service (if ANALYTICS_LOADED):
         - Login events (main.py:L743-755)
           - Fields: event_type='login', user_email, department, session_id, user_id
         - Department switch events (main.py:L926-937)
           - Fields: event_type='dept_switch', from_department, to_department
         - Error events (main.py:L956-967)
           - Fields: event_type='error', error_type, error_message

      2. Admin action logging via Python logger (logger.info):
         - Access grants (admin_routes.py:L387)
         - Access revocations (admin_routes.py:L434)
         - Dept head promotions (admin_routes.py:L494)
         - Dept head revocations (admin_routes.py:L537)
         - Super user promotions (admin_routes.py:L586)
         - Super user revocations (admin_routes.py:L623)

         Format: "[Admin] {actor_email} {action} {target_email} {details}"

      3. Request timing middleware (main.py:L324-331):
         - X-Response-Time header added to all responses
         - Performance tracking only, no audit trail

      4. Standard Python logging (logger.warning, logger.error):
         - Auth failures
         - Permission errors
         - WebSocket errors
         - No structured format, no database persistence

    audit_table: |
      DELETED - access_audit_log table removed during schema migration

      Evidence:
      - admin_routes.py:L656 returns 501 "Audit log table deleted during schema migration"
      - admin_routes.py:L85-96 defines AuditLogEntry model (unused)
      - admin_routes.py:L639-660 has audit endpoint stub

      Previous schema (from model):
      - id (string)
      - action (string)
      - actor_email (optional string)
      - target_email (optional string)
      - department_slug (optional string)
      - old_value (optional string)
      - new_value (optional string)
      - reason (optional string)
      - created_at (datetime)
      - ip_address (optional string)

    audit_endpoints: |
      EXISTS but returns 501 Not Implemented:

      - GET /api/admin/audit (admin_routes.py:L639-660)
        Query params: action, target_email, department, limit, offset
        Status: Stubbed, returns "Audit log table deleted during schema migration"

    analytics_service: |
      EXISTS at auth/analytics_engine/analytics_service.py

      Methods available:
      - log_event(event_type, user_email, session_id, **kwargs)
      - get_dashboard_data(hours=24)

      Storage: Likely uses enterprise database (not file-based)

      Current event types logged:
      - login
      - dept_switch
      - error

  events_to_track:
    authentication:
      - login:
          location: "main.py:L743-755 (ALREADY LOGGED)"
          current: "analytics_service.log_event('login', ...)"
          missing_fields: ["ip_address", "user_agent", "auth_method"]

      - logout:
          location: "NONE - no logout endpoint"
          needed: "Add to auth/sso_routes.py or main.py"
          fields: ["user_email", "session_id", "logout_reason"]

      - token_refresh:
          location: "auth/sso_routes.py (exists but not logged)"
          needed: "Add audit log after refresh"
          fields: ["user_email", "token_type", "success"]

    authorization:
      - department_change:
          location: "main.py:L926-937 (ALREADY LOGGED)"
          current: "analytics_service.log_event('dept_switch', ...)"
          complete: true

      - access_denied:
          location: "Multiple HTTPException(403) calls"
          needed: "Wrap all 403s with audit log"
          fields: ["user_email", "attempted_resource", "required_permission"]

    admin_actions:
      - department_access_grant:
          location: "admin_routes.py:L345-400"
          current: "logger.info only (not in DB)"
          needed: "Add audit_service.log_access_grant()"
          line: "After L387"

      - department_access_revoke:
          location: "admin_routes.py:L403-447"
          current: "logger.info only (not in DB)"
          needed: "Add audit_service.log_access_revoke()"
          line: "After L434"

      - dept_head_promote:
          location: "admin_routes.py:L466-506"
          current: "logger.info only (not in DB)"
          needed: "Add audit_service.log_dept_head_change()"
          line: "After L494"

      - dept_head_revoke:
          location: "admin_routes.py:L509-549"
          current: "logger.info only (not in DB)"
          needed: "Add audit_service.log_dept_head_change()"
          line: "After L537"

      - super_user_promote:
          location: "admin_routes.py:L561-595"
          current: "logger.info only (not in DB)"
          needed: "Add audit_service.log_super_user_change()"
          line: "After L586"

      - super_user_revoke:
          location: "admin_routes.py:L598-632"
          current: "logger.info only (not in DB)"
          needed: "Add audit_service.log_super_user_change()"
          line: "After L623"

    document_access:
      - document_retrieval:
          location: "core/enterprise_rag.py (EnterpriseRAGRetriever)"
          current: "NONE"
          needed: "Log all RAG queries"
          fields: ["user_email", "department", "query_text", "doc_ids_retrieved", "threshold"]

      - search_query:
          location: "WebSocket message handler (main.py:L792-895)"
          current: "NONE"
          needed: "Log all user queries"
          fields: ["user_email", "department", "query_text", "session_id", "timestamp"]

    user_management:
      - user_created:
          location: "auth_service.py:L285-360 (get_or_create_user)"
          current: "NONE"
          needed: "Add audit log when new user created"
          line: "After L356 (return statement)"

      - user_viewed:
          location: "admin_routes.py:L213-265"
          current: "NONE"
          needed: "Optional - track who views user profiles"
          sensitivity: "Privacy concerns"

      - batch_import:
          location: "admin_routes.py:L776-793 (STUBBED)"
          current: "501 Not Implemented"
          needed: "When implemented, log all imports"
          fields: ["actor_email", "user_count", "success_count", "fail_count"]

  frontend:
    audit_page_status: "FUNCTIONAL but shows no data"

    audit_page_location: "frontend/src/routes/admin/audit/+page.svelte"

    ui_features:
      - Filter by action type (L12, L19-25)
      - Filter by target email (L13, L116-122)
      - Filter by department (L14, L126-132)
      - Pagination (L60-72, L212-232)
      - Date formatting (L74-83)
      - Action type badges with colors (L29-35, L168-175)

    expected_api: |
      GET /api/admin/audit
      Query params:
        - action: string (optional)
        - targetEmail: string (optional)  # Note: camelCase in UI, snake_case in API
        - department: string (optional)
        - limit: number (default 50)
        - offset: number (default 0)

      Response:
      {
        "success": true,
        "data": {
          "entries": [
            {
              "id": "uuid",
              "action": "grant",
              "actor_email": "admin@example.com",
              "target_email": "user@example.com",
              "department_slug": "warehouse",
              "old_value": null,
              "new_value": "read",
              "reason": "onboarding",
              "created_at": "2025-01-15T10:30:00Z",
              "ip_address": "192.168.1.1"
            }
          ],
          "total": 150,
          "limit": 50,
          "offset": 0
        }
      }

    admin_store_integration: |
      Location: frontend/src/lib/stores/admin.ts

      Expected methods (likely defined):
      - adminStore.loadAuditLog(filters) -> calls GET /api/admin/audit
      - auditEntries (writable store)
      - auditTotal (writable store)
      - auditLoading (writable store)

  integration_points:
    create_audit_service:
      file: "auth/audit_service.py (NEW)"

      class_structure: |
        ```python
        class AuditService:
            def __init__(self, db_config):
                self._pool = None  # psycopg2 pool

            def log_event(
                self,
                action: str,
                actor_email: str,
                target_email: Optional[str] = None,
                department_slug: Optional[str] = None,
                old_value: Optional[str] = None,
                new_value: Optional[str] = None,
                reason: Optional[str] = None,
                ip_address: Optional[str] = None,
                metadata: Optional[Dict] = None
            ):
                # Insert into enterprise.audit_log table
                pass

            def query_log(
                self,
                action: Optional[str] = None,
                target_email: Optional[str] = None,
                department: Optional[str] = None,
                limit: int = 50,
                offset: int = 0
            ) -> List[Dict]:
                # SELECT from enterprise.audit_log
                pass

        _audit_service = None

        def get_audit_service() -> AuditService:
            global _audit_service
            if _audit_service is None:
                _audit_service = AuditService(DB_CONFIG)
            return _audit_service
        ```

    integrate_into_admin_routes:
      location: "auth/admin_routes.py"

      import_statement: |
        Line 26 (after auth_service import):
        from .audit_service import get_audit_service

      wrapper_function: |
        Add after L145 (before endpoints):
        ```python
        def audit_log(
            action: str,
            actor: User,
            target_email: Optional[str] = None,
            department: Optional[str] = None,
            old_value: Optional[str] = None,
            new_value: Optional[str] = None,
            reason: Optional[str] = None
        ):
            """Helper to log admin actions."""
            try:
                audit = get_audit_service()
                audit.log_event(
                    action=action,
                    actor_email=actor.email,
                    target_email=target_email,
                    department_slug=department,
                    old_value=old_value,
                    new_value=new_value,
                    reason=reason
                )
            except Exception as e:
                logger.error(f"Failed to log audit event: {e}")
        ```

      insert_calls:
        - grant_access (L387): |
            audit_log(
                action="department_access_grant",
                actor=requester,
                target_email=target_email,
                department=request.department_slug,
                new_value=request.access_level,
                reason=request.reason
            )

        - revoke_access (L434): |
            audit_log(
                action="department_access_revoke",
                actor=requester,
                target_email=target_email,
                department=request.department_slug,
                reason=request.reason
            )

        - promote_to_dept_head (L494): |
            audit_log(
                action="dept_head_promote",
                actor=requester,
                target_email=request.target_email,
                department=request.department,
                new_value="dept_head"
            )

        - Similar for other admin actions...

    implement_audit_endpoint:
      location: "auth/admin_routes.py:L639-660"

      replace_stub_with: |
        ```python
        @admin_router.get("/audit", response_model=APIResponse)
        async def get_audit_log(
            x_user_email: str = Header(None, alias="X-User-Email"),
            action: Optional[str] = Query(None),
            target_email: Optional[str] = Query(None),
            department: Optional[str] = Query(None),
            limit: int = Query(50, ge=1, le=500),
            offset: int = Query(0, ge=0),
        ):
            """View audit log entries."""
            if not x_user_email:
                raise HTTPException(401, "X-User-Email header required")

            auth = get_auth_service()
            requester = auth.get_user_by_email(x_user_email)

            if not requester:
                raise HTTPException(401, "User not found")

            # Require admin access
            if not requester.is_super_user and not requester.dept_head_for:
                raise HTTPException(403, "Admin access required")

            # Non-super users can only see their departments
            if not requester.is_super_user and department:
                if department not in (requester.dept_head_for or []):
                    raise HTTPException(403, f"No access to {department} audit log")

            audit = get_audit_service()
            entries = audit.query_log(
                action=action,
                target_email=target_email,
                department=department,
                limit=limit,
                offset=offset
            )
            total = audit.count_log(
                action=action,
                target_email=target_email,
                department=department
            )

            return APIResponse(
                success=True,
                data={
                    "entries": entries,
                    "total": total,
                    "limit": limit,
                    "offset": offset
                }
            )
        ```

    log_websocket_events:
      location: "core/main.py"

      query_logging:
        where: "After L804 (before twin.think_streaming)"
        code: |
          # Log user query (optional - high volume)
          if AUDIT_LOGGING_ENABLED:
              audit = get_audit_service()
              audit.log_event(
                  action="user_query",
                  actor_email=user_email,
                  department_slug=effective_division,
                  metadata={
                      "session_id": session_id,
                      "query_length": len(content)
                  }
              )

      rag_retrieval_logging:
        where: "core/enterprise_rag.py in search() method"
        code: |
          # After retrieval (after L~150, wherever results are returned)
          audit = get_audit_service()
          audit.log_event(
              action="document_retrieval",
              actor_email=user_email,
              department_slug=department_id,
              metadata={
                  "query": query[:200],
                  "doc_count": len(results),
                  "threshold": threshold
              }
          )

  database_changes_needed:
    recreate_audit_table: |
      CREATE TABLE enterprise.audit_log (
          id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
          action VARCHAR(100) NOT NULL,
          actor_email VARCHAR(255),
          actor_user_id UUID REFERENCES enterprise.users(id),
          target_email VARCHAR(255),
          target_user_id UUID REFERENCES enterprise.users(id),
          department_slug VARCHAR(50),
          old_value TEXT,
          new_value TEXT,
          reason TEXT,
          ip_address INET,
          user_agent TEXT,
          metadata JSONB,
          created_at TIMESTAMP DEFAULT NOW(),

          INDEX idx_action (action),
          INDEX idx_actor (actor_email),
          INDEX idx_target (target_email),
          INDEX idx_department (department_slug),
          INDEX idx_created (created_at DESC)
      );

      -- Grant access
      GRANT SELECT, INSERT ON enterprise.audit_log TO app_user;

    retention_policy: |
      -- Optional: Add partition by month for large-scale deployments
      -- Or use TTL with:

      CREATE OR REPLACE FUNCTION cleanup_old_audit_logs()
      RETURNS void AS $$
      BEGIN
          DELETE FROM enterprise.audit_log
          WHERE created_at < NOW() - INTERVAL '1 year';
      END;
      $$ LANGUAGE plpgsql;

      -- Schedule with pg_cron or external scheduler

  recommended_table_schema:
    minimal: |
      Just what's needed for admin portal:
      - id, action, actor_email, target_email, department_slug
      - old_value, new_value, reason
      - created_at

    production: |
      Add operational fields:
      - actor_user_id (FK to users.id)
      - target_user_id (FK to users.id)
      - ip_address, user_agent
      - metadata (JSONB for flexible fields)
      - session_id (link to websocket sessions)

    compliance: |
      For SOC2/HIPAA/GDPR:
      - Add retention_expires_at (auto-deletion)
      - Add data_classification (PII, confidential, etc.)
      - Add compliance_flags (GDPR_EXPORT_REQUIRED, etc.)

  action_type_taxonomy:
    authentication:
      - login
      - logout
      - token_refresh
      - auth_failure

    authorization:
      - department_access_grant
      - department_access_revoke
      - dept_head_promote
      - dept_head_revoke
      - super_user_promote
      - super_user_revoke
      - access_denied

    data_access:
      - user_query
      - document_retrieval
      - search_performed
      - department_view

    user_management:
      - user_created
      - user_updated
      - user_deactivated
      - user_reactivated
      - batch_import

    session:
      - dept_switch
      - session_expired
      - connection_lost

  security_considerations:
    pii_handling: |
      Audit logs contain PII (emails). Consider:
      - Encrypt sensitive fields at rest
      - Hash emails for searchability (add email_hash column)
      - Implement audit log access controls (who can view?)
      - Add GDPR data export endpoint

    tamper_prevention: |
      - Make audit_log INSERT-only (no UPDATE/DELETE grants)
      - Use database triggers to prevent modifications
      - Consider blockchain-style hash linking (each entry hashes previous)
      - Regular backups with checksums

    performance: |
      - Partition by month/quarter for large datasets
      - Archive old logs to cold storage
      - Use JSONB for metadata (flexible + indexed)
      - Batch inserts if high volume (use queue)

  dependencies_and_blockers:
    none_blocking: |
      Can implement immediately. All infrastructure exists.

    decisions_needed:
      - Audit log retention period (90 days? 1 year? 7 years?)
      - Should user queries be logged? (privacy vs security trade-off)
      - Should RAG document access be logged? (compliance requirement?)
      - IP address collection (GDPR implications?)

  estimated_complexity:
    backend_effort: |
      - AuditService class: 2-3 hours
      - Database table + migration: 1 hour
      - Integrate into admin_routes: 2 hours
      - Implement audit endpoint: 1-2 hours
      - Add WebSocket query logging: 1 hour
      Total: 7-9 hours

    frontend_effort: |
      - Fix admin store API call: 0.5 hour (already built, just wire it)
      - Test audit page: 0.5 hour
      Total: 1 hour

    compliance_effort: |
      - Document audit log schema: 2 hours
      - Implement retention policy: 2 hours
      - Add GDPR export endpoint: 3 hours
      Total: 7 hours (if needed)

    total_basic: "8-10 hours for working audit log"
    total_production: "15-17 hours with compliance features"
