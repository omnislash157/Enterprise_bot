# ==============================================================================
# TASK 1: SESSION TIMEOUT/RECONNECT RECON
# ==============================================================================
# Mission: Map WebSocket lifecycle and state persistence integration points

websocket_recon:
  backend:
    endpoint_location: "core/main.py:L683"
    connection_state:
      - session_id tracked in ConnectionManager (dict at main.py:L659-677)
      - user_email established via verify message (main.py:L690)
      - tenant (TenantContext) holds department/division state (main.py:L693-697)
      - request_twin optionally set after auth (main.py:L691)

    auth_method: |
      Two-phase auth:
      1. WebSocket accepts connection immediately (no auth required)
      2. Client sends 'verify' message with email + division (main.py:L714-790)
      3. Backend validates via AuthService.get_or_create_user() (main.py:L719-721)
      4. Backend sends 'verified' confirmation with allowed departments

      Token validation:
      - Azure AD: validate_access_token() checks Microsoft Graph (main.py:L157-176)
      - Email fallback: X-User-Email header checked against AuthService (main.py:L180-201)
      - WebSocket verify message uses email directly (no token in WS auth flow)

    heartbeat: |
      EXISTS - ping/pong implemented
      - Client sends {"type": "ping"} (main.py:L711-712)
      - Server responds {"type": "pong"}
      - No automatic keepalive, client must drive
      - No timeout enforcement on server side

    persistence: |
      NONE - All state is in-memory only
      - ConnectionManager.active_connections is a dict (ephemeral)
      - No Redis, no Postgres session storage
      - ChatMemoryStore exists (memory/chat_memory.py) for chat history
        but NOT for connection state
      - Analytics events logged to database (login, dept_switch) but not
        used for session restoration

    session_metadata_tracked:
      - session_id (from URL path)
      - user_email (from verify message)
      - tenant.department (can change mid-session via set_division)
      - request_twin (EnterpriseTwin or CogTwin instance)
      - WebSocket object reference

    analytics_integration:
      - Login event logged (main.py:L743-755)
      - Department switch event logged (main.py:L926-937)
      - Error events logged (main.py:L956-967)
      - Uses analytics_service.log_event() if ANALYTICS_LOADED

  frontend:
    websocket_store_location: "frontend/src/lib/stores/websocket.ts"

    reconnect_logic: |
      EXISTS - Automatic reconnect with exponential backoff
      - Triggers on abnormal close (onclose handler, L108-116)
      - Exponential backoff: min(1000 * 2^(attempts-1), 10000)ms
      - Max 5 reconnect attempts (L42)
      - Respects intentionalClose flag (user-initiated disconnects)
      - Clears on successful reconnection (reconnectAttempts = 0, L84)

    state_persistence: |
      NONE - No localStorage/sessionStorage backing
      - Session store tracks messages in-memory (session.ts:L58-66)
      - Reconnect re-establishes connection but loses in-flight messages
      - No snapshot/restore of conversation state
      - Department selection persisted via pendingDivision variable (L89)
        but NOT across page reloads

    reconnect_trigger: |
      Triggered by WebSocket onclose event when:
      - event.wasClean === false (abnormal disconnect)
      - intentionalClose === false (not user-initiated)
      - currentSessionId exists (was previously connected)
      - reconnectAttempts < maxReconnectAttempts (5)

    connection_flow:
      1. session.init(sessionId, department) called (session.ts:L211)
      2. websocket.connect(sessionId) establishes WS connection
      3. Connection waits for 'connected' message
      4. Client sends 'verify' message with email + department (L222-233)
      5. Backend responds with 'verified' containing departments array
      6. If department mismatch, client sends 'set_division' (L130-137)

    department_switching:
      - Tracked in session store as currentDivision (session.ts:L64)
      - Can change via session.setDivision(division) (L240-265)
      - Sends {"type": "set_division", "division": X}
      - Backend validates access before confirming (main.py:L896-942)
      - Optimistic update + backend confirmation pattern

  gaps:
    missing_pieces:
      - No server-side session timeout mechanism
      - No WebSocket idle disconnect
      - No token refresh for WebSocket connections
      - No session state persistence (Redis/Postgres)
      - No conversation state snapshot/restore
      - No reconnect with message replay
      - No "last seen" timestamp tracking
      - No stale connection detection
      - No connection health monitoring
      - Frontend doesn't persist auth across page reload for WS

    edge_cases_not_handled:
      - User opens multiple tabs -> multiple WS connections, no session sharing
      - Connection drops mid-stream -> partial message lost, no recovery
      - User changes department while message streaming -> race condition
      - Token expires during long-running WS connection -> no refresh mechanism
      - Server restart -> all connections lost, no session restoration
      - Network partition -> reconnect may succeed but state is lost

  integration_points:
    backend:
      where_to_add_reconnect_logic: |
        No backend changes needed - client drives reconnect

        Optional enhancements:
        1. Add session_state table with schema:
           - session_id (primary key)
           - user_id (foreign key)
           - department (text)
           - last_heartbeat (timestamp)
           - state_snapshot (jsonb)
           - created_at, expires_at

        2. Add endpoint GET /api/sessions/{session_id}/state
           Location: core/main.py after L654
           Returns: {session_id, department, last_messages[]}

        3. Add SessionManager class in core/session_manager.py
           Methods:
           - save_snapshot(session_id, state) -> writes to Redis/Postgres
           - restore_snapshot(session_id) -> reads from storage
           - cleanup_expired() -> TTL-based expiry

      where_to_add_state_snapshot: |
        Option 1: Piggyback on ChatMemoryStore
        - File: memory/chat_memory.py
        - Add save_session_state(session_id, state_dict) method after L349
        - Store as JSON alongside chat exchanges

        Option 2: New SessionStore class
        - File: core/session_store.py (NEW)
        - Pattern: Match ChatMemoryStore architecture
        - Store location: data/sessions/session_{id}.json

        Option 3: Database (enterprise-grade)
        - Table: enterprise.websocket_sessions
        - Columns: session_id, user_id, department, state_json, last_heartbeat
        - Insert on verify (main.py:L757)
        - Update on set_division (main.py:L939)
        - Update on heartbeat (main.py:L712)

      where_to_add_restore: |
        In websocket_endpoint function (main.py:L683)
        After connection accepted (L685), before verify loop:

        ```python
        # Check if resuming existing session
        session_state = session_manager.restore_snapshot(session_id)
        if session_state:
            # Restore state
            tenant = TenantContext(**session_state['tenant'])
            user_email = session_state['user_email']
            # Send 'session_restored' message
            await websocket.send_json({
                "type": "session_restored",
                "department": tenant.department,
                "message_count": len(session_state.get('messages', []))
            })
        ```

      timeout_enforcement: |
        Add background task in startup_event (main.py:L356):

        ```python
        async def cleanup_stale_sessions():
            while True:
                await asyncio.sleep(60)  # Check every minute
                session_manager.cleanup_expired(max_age_minutes=30)

        asyncio.create_task(cleanup_stale_sessions())
        ```

      heartbeat_improvement: |
        Current: Client sends ping, server responds pong

        Enhancement in websocket_endpoint (main.py:L711-712):
        1. Track last_heartbeat timestamp per session
        2. Add timeout: if no message in 5 minutes, send server-side ping
        3. If client doesn't respond to ping in 30s, close connection
        4. Update last_heartbeat on ANY message (not just ping)

    frontend:
      where_to_add_local_persistence: |
        In session store (frontend/src/lib/stores/session.ts):

        1. Add saveState() method after L314:
           ```typescript
           saveState() {
               const state = get(store);
               localStorage.setItem(`session_${sessionId}`, JSON.stringify({
                   messages: state.messages,
                   currentDivision: state.currentDivision,
                   timestamp: Date.now()
               }));
           }
           ```

        2. Add restoreState() method:
           ```typescript
           restoreState(sessionId: string): SessionState | null {
               const saved = localStorage.getItem(`session_${sessionId}`);
               if (!saved) return null;
               const data = JSON.parse(saved);
               // Check if not stale (< 1 hour old)
               if (Date.now() - data.timestamp > 3600000) {
                   localStorage.removeItem(`session_${sessionId}`);
                   return null;
               }
               return data;
           }
           ```

        3. Call restoreState in init() method (L211)
        4. Call saveState on every message sent/received

      where_to_add_message_buffering: |
        In websocket store (frontend/src/lib/stores/websocket.ts):

        Add message queue for offline messages:
        ```typescript
        let messageQueue: any[] = [];

        send(data: any) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify(data));
            } else {
                messageQueue.push(data);
                console.warn('[WS] Queued message (not connected)');
            }
        }

        // In onopen handler (L83-87):
        ws.onopen = () => {
            // ... existing code ...
            // Flush queue
            while (messageQueue.length > 0) {
                const msg = messageQueue.shift();
                ws.send(JSON.stringify(msg));
            }
        };
        ```

      reconnect_ui_feedback: |
        Add to session store state (session.ts:L57-66):
        - connectionState: 'connected' | 'reconnecting' | 'disconnected'
        - reconnectAttempts: number

        Display banner in UI when connectionState !== 'connected'
        Show progress: "Reconnecting... (attempt 2/5)"

      token_refresh_integration: |
        In auth store (frontend/src/lib/stores/auth.ts:L109-116):

        Schedule refresh BEFORE token expires:
        ```typescript
        scheduleRefresh(expiresIn: number) {
            const refreshMs = (expiresIn - 60) * 1000;
            if (refreshTimeout) clearTimeout(refreshTimeout);
            if (refreshMs > 0) {
                refreshTimeout = window.setTimeout(async () => {
                    const success = await store.refresh();
                    if (success) {
                        // Reconnect WebSocket with new token
                        websocket.reconnect();
                    }
                }, refreshMs);
            }
        }
        ```

  recommended_implementation_order:
    phase_1_basic_persistence:
      - Add session state to localStorage (frontend)
      - Add session restore on page reload (frontend)
      - Add connection state UI indicator (frontend)

    phase_2_server_side_storage:
      - Create enterprise.websocket_sessions table (backend)
      - Add SessionManager class (backend)
      - Save state on verify and set_division (backend)
      - Add GET /api/sessions/{id}/state endpoint (backend)

    phase_3_reconnect_improvements:
      - Add message buffering to WebSocket store (frontend)
      - Add server-side timeout enforcement (backend)
      - Add stale session cleanup background task (backend)

    phase_4_advanced_features:
      - Add server-initiated pings (backend)
      - Add message replay on reconnect (backend + frontend)
      - Add cross-tab session sharing via BroadcastChannel (frontend)
      - Add connection quality monitoring (frontend)

  database_changes_needed:
    new_table: |
      CREATE TABLE enterprise.websocket_sessions (
          session_id VARCHAR(255) PRIMARY KEY,
          user_id UUID REFERENCES enterprise.users(id),
          department TEXT NOT NULL,
          state_snapshot JSONB,
          last_heartbeat TIMESTAMP DEFAULT NOW(),
          created_at TIMESTAMP DEFAULT NOW(),
          expires_at TIMESTAMP DEFAULT NOW() + INTERVAL '1 hour',
          INDEX idx_user_sessions (user_id),
          INDEX idx_expires (expires_at)
      );

    optional_columns_on_users: |
      -- Track last active session
      ALTER TABLE enterprise.users
      ADD COLUMN last_session_id VARCHAR(255),
      ADD COLUMN last_heartbeat TIMESTAMP;

  api_contract:
    restore_session:
      endpoint: GET /api/sessions/{session_id}/state
      request: null
      response: |
        {
          "session_id": "abc123",
          "user_email": "user@example.com",
          "department": "warehouse",
          "messages": [
            {"role": "user", "content": "...", "timestamp": "..."},
            {"role": "assistant", "content": "...", "timestamp": "..."}
          ],
          "last_heartbeat": "2025-01-15T10:30:00Z",
          "expires_at": "2025-01-15T11:00:00Z"
        }
      errors:
        404: Session not found or expired
        401: Unauthorized (not your session)

    save_session_snapshot:
      endpoint: POST /api/sessions/{session_id}/snapshot
      request: |
        {
          "department": "warehouse",
          "messages": [...],
          "metadata": {}
        }
      response: |
        {
          "success": true,
          "saved_at": "2025-01-15T10:30:00Z"
        }

  dependencies_and_blockers:
    none: |
      All infrastructure exists. No external dependencies.
      Can implement incrementally without breaking changes.

    decisions_needed:
      - Storage backend: Redis vs Postgres vs localStorage only?
      - Session TTL: 30 minutes? 1 hour? 24 hours?
      - Message replay: Full history or last N messages?
      - Cross-tab sync: Needed or single-tab only?

  estimated_complexity:
    backend_effort: "4-6 hours (basic session persistence)"
    frontend_effort: "3-4 hours (localStorage + reconnect UI)"
    database_effort: "1 hour (table creation + migration)"
    testing_effort: "4 hours (reconnect scenarios)"
    total: "12-15 hours for production-ready implementation"
